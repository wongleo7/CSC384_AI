Heuristics


	Due to the nature of the game ‘Go’, we had to use very strong heuristics in order to prune down the huge search space of our game so that the AI will be able to finish running within a reasonable timeframe. We implemented a couple heuristics, all of which were able to significantly decrease our runtimes and the number of nodes visited. Our first heuristic sorts the next available moves so that the move with the most influential vital spot (highest potential to create eyes) is pushed to the top of the queue for Beta nodes, and the probable least scoring values first on Alpha nodes. (Please reference our link to xmp.net in our references for more details on vital spots.) This coincides with the strategy of having decreasing values on Beta nodes and increasing values on alpha nodes to maximize pruning. As the goal of our game is to complete two eyes, our second sorting heuristic does exactly that. We sort our successor states based on the number of eyes they have. We give them weight for if they have ‘Real’ eyes, ‘False’ eyes, or ‘Unknown’ eyes. Each of these represent the stability of their eye, ‘Real’ being the least volatile while ‘False’ being the most volatile, Unknown is undetermined because the spots to determine if they are ‘Real’ or ‘False’ have not been occupied yet. Like our previous sorting algorithm, we have it increasing for alpha nodes and decreasing on Beta nodes. To be able to maximally utilize the two sorts to their maximum potential, once our first sorting algorithm does not find any more vital spots, we use our second sorting heuristic instead. This tag team technique works well because our second sort is well better suited for a late game strategy where the first one would most likely fail. Together with these few heuristics, we were able to reduce our search space approximately by half and was able to increase the depth of the tree to be able to get stronger results. Another heuristic we utilized is to prune the first level of the tree, normally this cannot be done but since we only need one survival state, we return the first correct move found. This significantly reduced the runtime of our algorithm, while still maintaining correct answers for all of our 13 test problems. Our heuristics mentioned are admissible due to the fact that they never overestimate the cost it takes to reach the desired state since they only help guide towards the goal and never explicitly suggest the estimate to reach the goal. With all of our heuristics working together, we were able the total runtime of our 13 problems from 949 seconds to a meager 163 seconds. That’s a decrease of 83%! The combined heuristics ultimately saved us a lot of time and they actually were able to increase the accuracy of our AI by allowing us to run at higher depths and also leading our heu
    
    
    
    
    
    
    
    
    For our state variables, we had ‘player’, ‘moves’, ‘board’, ‘connectedPieces’, ‘survivalState’, and ‘eyes’. Firstly, ‘player’ lets us know whose turn is it next so we could know for who we should calculate for next. Next, ‘moves’ is an array of legal moves for the current player, the player should only be able to pick from this list when selecting their next move. Naturally, ‘board’ is a dictionary containing the current state of the board which encodes the black and white pieces on the board and also the available spots. It may seem like we have redundant information as the board minus the pieces would give the available positions remaining, however, we have a predefined problem which may not always be played a square board. Our ‘connectedPieces’ is also a dictionary containing list of defender and attacker pieces that are connected as well as the number of liberties in each group. This data helps us better understand the complex board arrangement as knowing this information we could easily tell when an area is enveloped by opposing pieces. This significantly reduces processing times as it means that we do not need to process this every time we generate a new successor state. 

    
    
    Since our game is Tsumego Go and not Go itself, we only focused on whether or not the AI could survive the life part of the life and death problem. Unfortunately that means that if our algorithm were to play itself, it would most likely not be able to attack successfully against the defending AI. The killing was interactively fed in manually as a 1-player, versus AI type of game (where we had the solutions). Another limitation we had was due to the nature of our algorithm, we did not nearly have enough compute power to run at our desired terminal depth for extremely hard problems. Because of that, we had to limit our program to a search depth that we felt comfortable with, where the AI would be able to reach the solution on it’s own while not giving it too much constraint. Fortunately, we observed that this had little effect on our algorithm and does not give the AI a handicap, nor does it hinder the performance. We were able to tune all of the problems to an approximation to provide enough breathing room for the AI while not leaving it with too little resources. One of the biggest challenges we faced as encoding the rules of the game. The game of Go is extremely complex, especially with the definition of ‘eyes’. A huge part of the project was to determine the eyes, whether real, fake, or with an unknown status. 